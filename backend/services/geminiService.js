const fetch = require('node-fetch');
const cacheService = require('./cacheService');

class GeminiService {
  constructor(apiKey, model) {
    this.apiKey = apiKey || process.env.GEMINI_API_KEY;
    // Use the correct model name for Gemini 2.5 Flash
    this.model =
      model ||
      process.env.GEMINI_MODEL ||
      'gemini-2.5-flash';

    // Official Google AI API endpoint
    this.baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent`;

    // Rate limiting and retry configuration
    this.maxRetries = 3;
    this.retryDelay = 1000; // 1 second base delay
    this.requestQueue = [];
    this.isProcessingQueue = false;
    this.lastRequestTime = 0;
    this.minRequestInterval = 100; // Minimum 100ms between requests
  }

  /**
   * Check if API key is configured and valid
   */
  isConfigured() {
    return this.apiKey &&
      this.apiKey.trim() !== '' &&
      this.apiKey !== 'your-google-gemini-api-key-here' &&
      this.apiKey.length > 10;
  }

  /**
   * Validate API configuration
   */
  validateConfiguration() {
    if (!this.isConfigured()) {
      throw new Error('Gemini API key is not configured or invalid. Please set GEMINI_API_KEY in your environment variables.');
    }
  }

  /**
   * Generate cache key for AI requests
   */
  generateCacheKey(prompt, systemInstruction, chatHistory) {
    const content = JSON.stringify({ prompt, systemInstruction, chatHistory });
    return `ai:gemini:${Buffer.from(content).toString('base64').substring(0, 50)}`;
  }

  /**
   * Rate-limited API call with retry logic
   */
  async makeAPICall(requestData, retryCount = 0) {
    this.validateConfiguration();

    // Rate limiting
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;
    if (timeSinceLastRequest < this.minRequestInterval) {
      await this.sleep(this.minRequestInterval - timeSinceLastRequest);
    }
    this.lastRequestTime = Date.now();

    try {
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': this.apiKey,
        },
        body: JSON.stringify(requestData),
        timeout: 30000 // 30 second timeout
      });

      // Handle different HTTP error codes
      if (!response.ok) {
        const errorText = await response.text().catch(() => '');

        // Handle specific error codes
        if (response.status === 429) {
          throw new Error('RATE_LIMIT_EXCEEDED');
        } else if (response.status === 401) {
          throw new Error('INVALID_API_KEY');
        } else if (response.status === 403) {
          throw new Error('API_ACCESS_DENIED');
        } else if (response.status >= 500) {
          throw new Error('SERVER_ERROR');
        }

        throw new Error(`Gemini API HTTP ${response.status}: ${errorText || response.statusText}`);
      }

      const data = await response.json();

      if (data.error) {
        throw new Error(data.error.message || 'Unknown API error');
      }

      if (!data.candidates || data.candidates.length === 0) {
        throw new Error('No response generated by AI model');
      }

      return data.candidates[0]?.content?.parts?.[0]?.text || '';
    } catch (error) {
      // Handle retryable errors
      if (retryCount < this.maxRetries && this.isRetryableError(error)) {
        const delay = this.retryDelay * Math.pow(2, retryCount); // Exponential backoff
        console.log(`Retrying Gemini API call in ${delay}ms (attempt ${retryCount + 1}/${this.maxRetries})`);
        await this.sleep(delay);
        return this.makeAPICall(requestData, retryCount + 1);
      }

      throw this.enhanceError(error);
    }
  }

  /**
   * Check if error is retryable
   */
  isRetryableError(error) {
    const retryableErrors = ['RATE_LIMIT_EXCEEDED', 'SERVER_ERROR', 'ECONNRESET', 'ETIMEDOUT'];
    return retryableErrors.some(retryableError =>
      error.message.includes(retryableError) || error.code === retryableError
    );
  }

  /**
   * Enhance error with user-friendly messages
   */
  enhanceError(error) {
    const errorMessage = error.message || error.toString();

    if (errorMessage.includes('INVALID_API_KEY') || errorMessage.includes('401')) {
      return new Error('Invalid Gemini API key. Please check your GEMINI_API_KEY environment variable.');
    } else if (errorMessage.includes('RATE_LIMIT_EXCEEDED') || errorMessage.includes('429')) {
      return new Error('AI service rate limit exceeded. Please try again in a few moments.');
    } else if (errorMessage.includes('API_ACCESS_DENIED') || errorMessage.includes('403')) {
      return new Error('Access denied to Gemini API. Please check your API key permissions.');
    } else if (errorMessage.includes('SERVER_ERROR') || errorMessage.includes('5')) {
      return new Error('AI service is temporarily unavailable. Please try again later.');
    } else if (errorMessage.includes('timeout') || errorMessage.includes('ETIMEDOUT')) {
      return new Error('AI service request timed out. Please try again.');
    }

    return error;
  }

  /**
   * Sleep utility for delays
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Helper to make API calls with the official Google format
  async generateContent(prompt, systemInstruction = '', chatHistory = [], useCache = true) {
    try {
      // Check cache first if enabled
      if (useCache) {
        const cacheKey = this.generateCacheKey(prompt, systemInstruction, chatHistory);
        const cachedResult = cacheService.get(cacheKey);
        if (cachedResult) {
          return cachedResult;
        }
      }

      // Build the contents array with proper format
      const contents = [];

      // Add system instruction as the first user message if provided
      if (systemInstruction) {
        contents.push({
          role: 'user',
          parts: [{ text: systemInstruction }]
        });
        contents.push({
          role: 'model',
          parts: [{ text: "I understand. I'll help you with that." }]
        });
      }

      // Add chat history if provided
      chatHistory.forEach(msg => {
        contents.push({
          role: msg.role || 'user',
          parts: [{ text: msg.content }]
        });
      });

      // Add the current prompt
      contents.push({
        role: 'user',
        parts: [{ text: prompt }]
      });

      const requestData = {
        contents,
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 2048,
        },
        safetySettings: [
          {
            category: 'HARM_CATEGORY_HARASSMENT',
            threshold: 'BLOCK_NONE'
          },
          {
            category: 'HARM_CATEGORY_HATE_SPEECH',
            threshold: 'BLOCK_NONE'
          },
          {
            category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
            threshold: 'BLOCK_NONE'
          },
          {
            category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
            threshold: 'BLOCK_NONE'
          }
        ]
      };

      const result = await this.makeAPICall(requestData);

      // Cache the result if enabled
      if (useCache && result) {
        const cacheKey = this.generateCacheKey(prompt, systemInstruction, chatHistory);
        cacheService.set(cacheKey, result, 3600); // Cache for 1 hour
      }

      return result;
    } catch (error) {
      console.error('Gemini API error:', error);
      throw error;
    }
  }

  // NEW: Conversational AI that can answer questions about chat history
  async askAboutChatHistory(question, chatMessages, chatMetadata) {
    const systemInstruction = `You are a knowledgeable AI assistant for a couple's chat application. 
You have access to their complete chat history and can answer questions about their conversations, patterns, memories, and activities.

Be warm, supportive, and conversational in your responses. Use emojis occasionally to make it feel more personal.
When providing statistics or dates, be specific and accurate.
If you don't have enough information to answer a question, say so politely and suggest what kind of information would help.`;

    // Prepare context from chat history
    const chatContext = this.prepareChatContext(chatMessages, chatMetadata);

    const prompt = `Based on the chat history and metadata below, please answer this question: "${question}"

${chatContext}

Please provide a helpful, accurate, and engaging response.`;

    return await this.generateContent(prompt, systemInstruction);
  }

  // Helper to prepare chat context for AI analysis
  prepareChatContext(messages, metadata) {
    const sortedMessages = messages.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    const totalMessages = messages.length;

    // Get basic statistics
    const messagesBySender = {};
    const messagesByDate = {};
    const wordCounts = {};

    messages.forEach(msg => {
      // Count by sender
      const senderName = msg.sender?.name || 'Unknown';
      messagesBySender[senderName] = (messagesBySender[senderName] || 0) + 1;

      // Count by date
      const date = new Date(msg.createdAt).toDateString();
      if (!messagesByDate[date]) messagesByDate[date] = [];
      messagesByDate[date].push(msg);

      // Count words
      const words = msg.content.text.toLowerCase().split(/\s+/);
      words.forEach(word => {
        if (word.length > 2) {
          wordCounts[word] = (wordCounts[word] || 0) + 1;
        }
      });
    });

    // Get recent messages sample
    const recentMessages = sortedMessages.slice(-50).map(msg => {
      return `[${new Date(msg.createdAt).toLocaleDateString()}] ${msg.sender?.name}: ${msg.content.text}`;
    }).join('\n');

    // Get first and last message dates
    const firstMessage = sortedMessages[0];
    const lastMessage = sortedMessages[sortedMessages.length - 1];

    return `
=== CHAT STATISTICS ===
Total Messages: ${totalMessages}
Participants: ${Object.keys(messagesBySender).join(', ')}
Messages by Sender: ${Object.entries(messagesBySender).map(([name, count]) => `${name}: ${count}`).join(', ')}
First Message: ${firstMessage ? new Date(firstMessage.createdAt).toLocaleDateString() : 'N/A'}
Last Message: ${lastMessage ? new Date(lastMessage.createdAt).toLocaleDateString() : 'N/A'}
Total Days with Messages: ${Object.keys(messagesByDate).length}

=== CHAT METADATA ===
Relationship Start: ${metadata?.relationshipStartDate || 'Not set'}
Anniversary Date: ${metadata?.anniversaryDate || 'Not set'}
Chat Theme: ${metadata?.theme || 'classic'}

=== SAMPLE RECENT MESSAGES ===
${recentMessages}

=== TOP WORDS USED ===
${Object.entries(wordCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20)
        .map(([word, count]) => `${word}: ${count}`)
        .join(', ')}

=== MESSAGES BY DATE (last 10 days) ===
${Object.entries(messagesByDate)
        .slice(-10)
        .map(([date, msgs]) => `${date}: ${msgs.length} messages`)
        .join('\n')}
    `;
  }

  /**
   * Advanced relationship health scoring algorithm
   * Combines AI analysis with quantitative metrics
   */
  async analyzeRelationshipHealthWithContext(messages, stats, chatMetadata) {
    try {
      // Calculate quantitative health metrics
      const quantitativeScore = this.calculateQuantitativeHealthScore(messages, stats, chatMetadata);

      // Get AI qualitative analysis
      const qualitativeAnalysis = await this.getQualitativeHealthAnalysis(messages, stats, chatMetadata);

      // Combine scores with weighted average
      const finalHealthScore = Math.round((quantitativeScore * 0.4) + (qualitativeAnalysis.healthScore * 0.6));

      return {
        healthScore: Math.min(Math.max(finalHealthScore, 1), 10), // Ensure score is between 1-10
        quantitativeMetrics: {
          score: quantitativeScore,
          factors: this.getQuantitativeFactors(messages, stats, chatMetadata)
        },
        qualitativeAnalysis,
        communicationPatterns: qualitativeAnalysis.communicationPatterns || [],
        positiveObservations: qualitativeAnalysis.positiveObservations || [],
        areasForGrowth: qualitativeAnalysis.areasForGrowth || [],
        suggestions: qualitativeAnalysis.suggestions || [],
        detailedMetrics: this.calculateDetailedMetrics(messages, stats, chatMetadata)
      };
    } catch (error) {
      console.error('Error in relationship health analysis:', error);
      // Return fallback analysis
      return {
        healthScore: 7,
        communicationPatterns: ['Regular communication'],
        positiveObservations: ['Active conversation'],
        areasForGrowth: ['Continue building connection'],
        suggestions: ['Keep communicating regularly'],
        error: 'Detailed analysis unavailable'
      };
    }
  }

  /**
   * Calculate quantitative relationship health score based on metrics
   */
  calculateQuantitativeHealthScore(messages, stats, chatMetadata) {
    let score = 5; // Base score
    const factors = [];

    // Message frequency factor (0-2 points)
    const avgMessagesPerDay = stats.avgMessagesPerDay || 0;
    if (avgMessagesPerDay > 20) {
      score += 2;
      factors.push('High message frequency (+2)');
    } else if (avgMessagesPerDay > 10) {
      score += 1;
      factors.push('Good message frequency (+1)');
    } else if (avgMessagesPerDay < 2) {
      score -= 1;
      factors.push('Low message frequency (-1)');
    }

    // Message balance factor (0-1.5 points)
    const messageBalance = this.calculateMessageBalance(stats.messagesByUser);
    if (messageBalance > 0.8) {
      score += 1.5;
      factors.push('Excellent message balance (+1.5)');
    } else if (messageBalance > 0.6) {
      score += 1;
      factors.push('Good message balance (+1)');
    } else if (messageBalance < 0.3) {
      score -= 1;
      factors.push('Poor message balance (-1)');
    }

    // Response time factor (0-1 points)
    if (stats.responseTimeStats && stats.responseTimeStats.average) {
      const avgResponseTime = stats.responseTimeStats.average;
      if (avgResponseTime < 60) { // Less than 1 hour
        score += 1;
        factors.push('Quick response times (+1)');
      } else if (avgResponseTime > 1440) { // More than 24 hours
        score -= 0.5;
        factors.push('Slow response times (-0.5)');
      }
    }

    // Conversation consistency (0-1 points)
    const consistencyScore = this.calculateConsistencyScore(messages);
    if (consistencyScore > 0.8) {
      score += 1;
      factors.push('Consistent communication (+1)');
    } else if (consistencyScore < 0.4) {
      score -= 0.5;
      factors.push('Inconsistent communication (-0.5)');
    }

    // Sentiment factor (0-1 points)
    const sentimentScore = this.calculateSentimentScore(messages);
    if (sentimentScore > 0.7) {
      score += 1;
      factors.push('Positive sentiment (+1)');
    } else if (sentimentScore < 0.3) {
      score -= 1;
      factors.push('Negative sentiment (-1)');
    }

    // Relationship duration bonus (0-0.5 points)
    if (chatMetadata?.relationshipStartDate) {
      const relationshipDays = (new Date() - new Date(chatMetadata.relationshipStartDate)) / (1000 * 60 * 60 * 24);
      if (relationshipDays > 365) {
        score += 0.5;
        factors.push('Long-term relationship (+0.5)');
      }
    }

    return Math.min(Math.max(Math.round(score), 1), 10);
  }

  /**
   * Get AI-powered qualitative analysis
   */
  async getQualitativeHealthAnalysis(messages, stats, chatMetadata) {
    const systemInstruction = `You are a relationship counselor AI specializing in analyzing couple communication patterns. 
Be supportive, positive, and constructive in your analysis. Focus on strengths while gently suggesting improvements.
Provide specific insights based on the actual chat data provided.`;

    const chatContext = this.prepareChatContext(messages, chatMetadata);

    const prompt = `Analyze this couple's relationship based on their chat data:

${chatContext}

Provide insights in this exact JSON format:
{
  "healthScore": 8,
  "communicationPatterns": ["pattern1", "pattern2"],
  "positiveObservations": ["observation1", "observation2"],
  "areasForGrowth": ["area1", "area2"],
  "suggestions": ["suggestion1", "suggestion2"]
}`;

    const analysis = await this.generateContent(prompt, systemInstruction);
    return this.parseRelationshipAnalysis(analysis);
  }

  /**
   * Calculate message balance between participants
   */
  calculateMessageBalance(messagesByUser) {
    const userCounts = Object.values(messagesByUser).map(user => user.count || 0);
    if (userCounts.length < 2) return 1;

    const total = userCounts.reduce((sum, count) => sum + count, 0);
    const ratios = userCounts.map(count => count / total);

    // Calculate balance score (1 = perfect balance, 0 = complete imbalance)
    const minRatio = Math.min(...ratios);
    return minRatio * 2; // Scale to 0-1 range
  }

  /**
   * Calculate conversation consistency score
   */
  calculateConsistencyScore(messages) {
    if (messages.length < 7) return 0.5; // Not enough data

    // Group messages by day
    const messagesByDay = {};
    messages.forEach(msg => {
      const day = new Date(msg.createdAt).toDateString();
      messagesByDay[day] = (messagesByDay[day] || 0) + 1;
    });

    const dailyCounts = Object.values(messagesByDay);
    const avgDaily = dailyCounts.reduce((sum, count) => sum + count, 0) / dailyCounts.length;

    // Calculate coefficient of variation (lower = more consistent)
    const variance = dailyCounts.reduce((sum, count) => sum + Math.pow(count - avgDaily, 2), 0) / dailyCounts.length;
    const stdDev = Math.sqrt(variance);
    const coefficientOfVariation = stdDev / avgDaily;

    // Convert to consistency score (0-1, higher = more consistent)
    return Math.max(0, 1 - (coefficientOfVariation / 2));
  }

  /**
   * Calculate overall sentiment score
   */
  calculateSentimentScore(messages) {
    let positiveCount = 0;
    let negativeCount = 0;
    let totalCount = 0;

    const positiveWords = [
      'love', 'happy', 'good', 'great', 'awesome', 'amazing', 'wonderful', 'beautiful',
      'perfect', 'excellent', 'fantastic', 'brilliant', 'lovely', 'sweet', 'cute',
      '❤️', '😍', '😊', '😘', '💕', '💖', '💗', '💝', '🥰', '😄', '😃', '😀'
    ];

    const negativeWords = [
      'sad', 'angry', 'bad', 'terrible', 'awful', 'hate', 'horrible', 'disgusting',
      'annoying', 'frustrated', 'disappointed', 'upset', 'worried', 'stressed',
      '😢', '😭', '😠', '😡', '😞', '😔', '😟', '😰', '😨', '😱'
    ];

    messages.forEach(msg => {
      const text = msg.content.text.toLowerCase();
      totalCount++;

      let messagePositive = false;
      let messageNegative = false;

      positiveWords.forEach(word => {
        if (text.includes(word)) messagePositive = true;
      });

      negativeWords.forEach(word => {
        if (text.includes(word)) messageNegative = true;
      });

      if (messagePositive) positiveCount++;
      if (messageNegative) negativeCount++;
    });

    if (totalCount === 0) return 0.5;

    const positiveRatio = positiveCount / totalCount;
    const negativeRatio = negativeCount / totalCount;

    // Return sentiment score (0-1, higher = more positive)
    return Math.max(0, Math.min(1, 0.5 + (positiveRatio - negativeRatio)));
  }

  /**
   * Get quantitative factors for transparency
   */
  getQuantitativeFactors(messages, stats, chatMetadata) {
    return {
      messageFrequency: stats.avgMessagesPerDay || 0,
      messageBalance: this.calculateMessageBalance(stats.messagesByUser),
      responseTime: stats.responseTimeStats?.average || 0,
      consistency: this.calculateConsistencyScore(messages),
      sentiment: this.calculateSentimentScore(messages),
      relationshipDuration: chatMetadata?.relationshipStartDate ?
        Math.floor((new Date() - new Date(chatMetadata.relationshipStartDate)) / (1000 * 60 * 60 * 24)) : 0
    };
  }

  /**
   * Calculate detailed metrics for comprehensive analysis
   */
  calculateDetailedMetrics(messages, stats, chatMetadata) {
    return {
      communicationStyle: this.analyzeCommunicationStyle(messages),
      emotionalExpression: this.analyzeEmotionalExpression(messages),
      topicDiversity: this.analyzeTopicDiversity(messages),
      engagementLevel: this.analyzeEngagementLevel(messages, stats),
      supportiveness: this.analyzeSupportiveness(messages)
    };
  }

  /**
   * Analyze communication style patterns
   */
  analyzeCommunicationStyle(messages) {
    let questionCount = 0;
    let exclamationCount = 0;
    let avgMessageLength = 0;

    messages.forEach(msg => {
      const text = msg.content.text;
      if (text.includes('?')) questionCount++;
      if (text.includes('!')) exclamationCount++;
      avgMessageLength += text.length;
    });

    avgMessageLength = avgMessageLength / messages.length;

    return {
      questionFrequency: questionCount / messages.length,
      excitementLevel: exclamationCount / messages.length,
      averageMessageLength: Math.round(avgMessageLength),
      style: avgMessageLength > 100 ? 'detailed' : avgMessageLength > 30 ? 'moderate' : 'concise'
    };
  }

  /**
   * Analyze emotional expression in messages
   */
  analyzeEmotionalExpression(messages) {
    const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;

    let emojiCount = 0;
    let emotionalWords = 0;

    const emotionalKeywords = [
      'feel', 'feeling', 'emotion', 'heart', 'soul', 'mind', 'think', 'believe',
      'hope', 'dream', 'wish', 'want', 'need', 'miss', 'remember', 'forget'
    ];

    messages.forEach(msg => {
      const text = msg.content.text;
      const emojis = text.match(emojiRegex) || [];
      emojiCount += emojis.length;

      emotionalKeywords.forEach(keyword => {
        if (text.toLowerCase().includes(keyword)) emotionalWords++;
      });
    });

    return {
      emojiUsage: emojiCount / messages.length,
      emotionalLanguage: emotionalWords / messages.length,
      expressiveness: (emojiCount + emotionalWords) / messages.length
    };
  }

  /**
   * Analyze topic diversity in conversations
   */
  analyzeTopicDiversity(messages) {
    const words = [];
    messages.forEach(msg => {
      const messageWords = msg.content.text.toLowerCase()
        .split(/\s+/)
        .filter(word => word.length > 3)
        .filter(word => !this.isStopWord(word));
      words.push(...messageWords);
    });

    const uniqueWords = new Set(words);
    const diversity = uniqueWords.size / words.length;

    return {
      uniqueWordRatio: diversity,
      totalUniqueWords: uniqueWords.size,
      diversity: diversity > 0.3 ? 'high' : diversity > 0.2 ? 'medium' : 'low'
    };
  }

  /**
   * Analyze engagement level between participants
   */
  analyzeEngagementLevel(messages, stats) {
    const responseTimeAvg = stats.responseTimeStats?.average || 0;
    const messageBalance = this.calculateMessageBalance(stats.messagesByUser);

    let engagementScore = 0;

    // Quick responses indicate high engagement
    if (responseTimeAvg < 60) engagementScore += 3;
    else if (responseTimeAvg < 300) engagementScore += 2;
    else if (responseTimeAvg < 1440) engagementScore += 1;

    // Balanced participation indicates engagement
    if (messageBalance > 0.7) engagementScore += 2;
    else if (messageBalance > 0.5) engagementScore += 1;

    return {
      score: Math.min(engagementScore, 5),
      level: engagementScore >= 4 ? 'high' : engagementScore >= 2 ? 'medium' : 'low',
      factors: {
        responseTime: responseTimeAvg,
        participation: messageBalance
      }
    };
  }

  /**
   * Analyze supportiveness in communication
   */
  analyzeSupportiveness(messages) {
    const supportiveWords = [
      'support', 'help', 'care', 'understand', 'listen', 'here for you',
      'proud', 'believe in you', 'you can do it', 'i\'m here', 'together'
    ];

    let supportiveCount = 0;

    messages.forEach(msg => {
      const text = msg.content.text.toLowerCase();
      supportiveWords.forEach(phrase => {
        if (text.includes(phrase)) supportiveCount++;
      });
    });

    const supportivenessRatio = supportiveCount / messages.length;

    return {
      ratio: supportivenessRatio,
      count: supportiveCount,
      level: supportivenessRatio > 0.1 ? 'high' : supportivenessRatio > 0.05 ? 'medium' : 'low'
    };
  }

  /**
   * Check if word is a stop word (enhanced version)
   */
  isStopWord(word) {
    const stopWords = new Set([
      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
      'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',
      'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'shall',
      'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
      'my', 'your', 'his', 'her', 'its', 'our', 'their', 'this', 'that', 'these', 'those',
      'what', 'when', 'where', 'why', 'how', 'who', 'which', 'whose', 'whom',
      'yes', 'no', 'not', 'so', 'too', 'very', 'just', 'now', 'then', 'here', 'there'
    ]);

    return stopWords.has(word.toLowerCase());
  }

  // Analyze chat sentiment and relationship health
  async analyzeRelationshipHealth(messages, stats) {
    const systemInstruction = `You are a relationship counselor AI specializing in analyzing couple communication patterns. 
    Be supportive, positive, and constructive in your analysis. Focus on strengths while gently suggesting improvements.`;

    const prompt = `Analyze this couple's chat data and provide insights:

Total Messages: ${stats.totalMessages}
Average Messages Per Day: ${stats.avgMessagesPerDay}
Message Balance: ${stats.messagesBySender.map(s => `${s.sender.name}: ${s.count} messages`).join(', ')}

Recent message samples:
${messages.slice(0, 20).map(m => `${m.sender}: ${m.content.text}`).join('\n')}

Please provide:
1. Overall relationship health score (1-10)
2. Communication pattern analysis
3. Positive observations
4. Areas for growth
5. Specific suggestions for better communication`;

    const analysis = await this.generateContent(prompt, systemInstruction);
    return this.parseRelationshipAnalysis(analysis);
  }

  /**
   * Generate personalized conversation starters based on chat history and context
   */
  async generateConversationStarters(chatMetadata, recentTopics, chatHistory = []) {
    try {
      const systemInstruction = `You are a romantic relationship expert who creates meaningful conversation starters for couples. 
Be creative, thoughtful, and appropriate for couples in committed relationships. Consider their communication patterns and interests.`;

      // Analyze relationship stage and communication style
      const relationshipContext = this.analyzeRelationshipContext(chatMetadata, recentTopics, chatHistory);

      const prompt = `Create 5 unique conversation starters for a couple with these characteristics:

RELATIONSHIP CONTEXT:
${chatMetadata?.anniversaryDate ? `Anniversary: ${new Date(chatMetadata.anniversaryDate).toLocaleDateString()}` : ''}
${chatMetadata?.relationshipStartDate ? `Together since: ${new Date(chatMetadata.relationshipStartDate).toLocaleDateString()}` : ''}
${chatMetadata?.theme ? `Relationship theme: ${chatMetadata.theme}` : ''}

RECENT CONVERSATION TOPICS:
${recentTopics.length > 0 ? recentTopics.join(', ') : 'General conversation'}

COMMUNICATION STYLE:
${relationshipContext.communicationStyle}

Create conversation starters that:
- Deepen emotional connection and intimacy
- Are fun, engaging, and spark curiosity
- Explore shared dreams, goals, and memories
- Celebrate their unique relationship journey
- Encourage meaningful dialogue and discovery
- Match their communication style and relationship stage
- Include both light-hearted and deeper topics

Format each starter as a complete question or prompt that naturally leads to engaging conversation.`;

      const response = await this.generateContent(prompt, systemInstruction, [], true);
      const starters = this.parseConversationStarters(response);

      // Add context-aware starters if AI response is limited
      if (starters.length < 3) {
        const fallbackStarters = this.generateFallbackConversationStarters(chatMetadata, recentTopics);
        starters.push(...fallbackStarters);
      }

      return starters.slice(0, 5);
    } catch (error) {
      console.error('Error generating conversation starters:', error);
      return this.generateFallbackConversationStarters(chatMetadata, recentTopics);
    }
  }

  /**
   * Analyze relationship context for better conversation starters
   */
  analyzeRelationshipContext(chatMetadata, recentTopics, chatHistory) {
    let relationshipStage = 'established';
    let communicationStyle = 'balanced';

    // Determine relationship stage
    if (chatMetadata?.relationshipStartDate) {
      const daysTogether = (new Date() - new Date(chatMetadata.relationshipStartDate)) / (1000 * 60 * 60 * 24);
      if (daysTogether < 90) relationshipStage = 'new';
      else if (daysTogether < 365) relationshipStage = 'developing';
      else if (daysTogether > 1095) relationshipStage = 'long-term';
    }

    // Analyze communication style from recent topics
    const casualTopics = ['food', 'movie', 'work', 'weather', 'funny'];
    const deepTopics = ['future', 'dream', 'feel', 'love', 'relationship', 'family'];

    const casualCount = recentTopics.filter(topic =>
      casualTopics.some(casual => topic.includes(casual))
    ).length;

    const deepCount = recentTopics.filter(topic =>
      deepTopics.some(deep => topic.includes(deep))
    ).length;

    if (deepCount > casualCount) communicationStyle = 'deep';
    else if (casualCount > deepCount * 2) communicationStyle = 'casual';

    return {
      relationshipStage,
      communicationStyle: `${communicationStyle} communication style in a ${relationshipStage} relationship`
    };
  }

  /**
   * Generate fallback conversation starters when AI fails
   */
  generateFallbackConversationStarters(chatMetadata, recentTopics) {
    const starters = [
      "What's one thing you've learned about yourself since we've been together?",
      "If we could travel anywhere together right now, where would you want to go and why?",
      "What's your favorite memory of us from this past month?",
      "What's something you're excited about in our future together?",
      "If you could describe our relationship in three words, what would they be?"
    ];

    // Customize based on recent topics
    if (recentTopics.includes('work') || recentTopics.includes('job')) {
      starters.push("What would your dream job be if money wasn't a factor, and how can I support you in getting there?");
    }

    if (recentTopics.includes('family') || recentTopics.includes('home')) {
      starters.push("What traditions from our families do you want to continue, and what new ones should we create?");
    }

    if (recentTopics.includes('food') || recentTopics.includes('cooking')) {
      starters.push("What's a dish that reminds you of home, and can we cook it together sometime?");
    }

    return starters.slice(0, 5);
  }

  // Analyze emoji usage and suggest fun responses
  async analyzeEmojiMeaning(emojiStats, context) {
    const systemInstruction = `You are a playful communication expert who understands emoji usage in romantic relationships. 
    Be fun, lighthearted, and insightful about what emoji patterns reveal about the couple.`;

    const prompt = `Analyze this couple's emoji usage:
Top emojis used: ${emojiStats.topEmojis.slice(0, 10).map(e => `${e.emoji} (${e.count}x)`).join(', ')}
Context: Recent chat about "${context}"

Provide:
1. What their emoji choices say about their relationship
2. Fun observations about their communication style
3. Suggested emojis they might enjoy using
4. A playful "emoji horoscope" for their relationship`;

    const response = await this.generateContent(prompt, systemInstruction);
    return this.parseEmojiAnalysis(response);
  }

  /**
   * Generate personalized date ideas based on chat history and interests
   */
  async generateDateIdeas(chatHistory, interests, location = 'local', chatMetadata = {}) {
    try {
      const systemInstruction = `You are a romantic date planning expert who creates personalized, creative date ideas for couples. 
Consider their interests, communication style, relationship dynamic, and relationship stage. Be creative and thoughtful.`;

      // Analyze relationship context for better date suggestions
      const relationshipContext = this.analyzeDateContext(chatHistory, interests, chatMetadata);

      const prompt = `Create 5 unique, personalized date ideas for a couple with these characteristics:

RELATIONSHIP CONTEXT:
${chatMetadata?.relationshipStartDate ? `Together since: ${new Date(chatMetadata.relationshipStartDate).toLocaleDateString()}` : ''}
${chatMetadata?.anniversaryDate ? `Anniversary: ${new Date(chatMetadata.anniversaryDate).toLocaleDateString()}` : ''}
Relationship stage: ${relationshipContext.stage}
Communication style: ${relationshipContext.communicationStyle}

INTERESTS & PREFERENCES:
Detected interests: ${interests.length > 0 ? interests.join(', ') : 'General activities'}
Location preference: ${location}
Budget considerations: ${relationshipContext.budgetStyle}

CONVERSATION PATTERNS:
${relationshipContext.conversationInsights}

Create date ideas that:
- Are personalized to their specific interests and relationship stage
- Include a mix of romantic, adventurous, cozy, and unique options
- Vary in budget from free/low-cost to special occasion splurges
- Are appropriate for their location preference
- Include specific activity suggestions and logistics
- Provide conversation topics or questions for each date
- Consider their communication style and relationship dynamic
- Create opportunities for deeper connection and shared experiences

For each date idea, provide:
1. Date title/theme
2. Detailed activity description
3. Why it's perfect for this couple
4. Conversation starters or topics
5. Approximate budget range
6. Best time/season for this date

Format as a structured list with clear sections for each date.`;

      const response = await this.generateContent(prompt, systemInstruction, [], true);
      const dateIdeas = this.parseDateIdeas(response);

      // Add fallback date ideas if AI response is limited
      if (dateIdeas.length < 3) {
        const fallbackIdeas = this.generateFallbackDateIdeas(interests, location, chatMetadata);
        dateIdeas.push(...fallbackIdeas);
      }

      return dateIdeas.slice(0, 5);
    } catch (error) {
      console.error('Error generating date ideas:', error);
      return this.generateFallbackDateIdeas(interests, location, chatMetadata);
    }
  }

  /**
   * Analyze context for better date suggestions
   */
  analyzeDateContext(chatHistory, interests, chatMetadata) {
    let stage = 'established';
    let communicationStyle = 'balanced';
    let budgetStyle = 'mixed budget';

    // Determine relationship stage
    if (chatMetadata?.relationshipStartDate) {
      const daysTogether = (new Date() - new Date(chatMetadata.relationshipStartDate)) / (1000 * 60 * 60 * 24);
      if (daysTogether < 90) {
        stage = 'new relationship - focus on getting to know each other';
        budgetStyle = 'budget-conscious with some special treats';
      } else if (daysTogether < 365) {
        stage = 'developing relationship - building deeper connections';
        budgetStyle = 'moderate budget with meaningful experiences';
      } else if (daysTogether > 1095) {
        stage = 'long-term relationship - maintaining spark and creating new memories';
        budgetStyle = 'varied budget from cozy nights to special celebrations';
      }
    }

    // Analyze interests for activity preferences
    const activeInterests = ['hiking', 'sport', 'gym', 'running', 'bike', 'dance'];
    const culturalInterests = ['art', 'museum', 'music', 'book', 'theater', 'concert'];
    const foodInterests = ['food', 'cooking', 'restaurant', 'wine', 'coffee'];
    const homeInterests = ['movie', 'game', 'reading', 'cooking'];

    const isActive = interests.some(interest => activeInterests.some(active => interest.includes(active)));
    const isCultural = interests.some(interest => culturalInterests.some(cultural => interest.includes(cultural)));
    const isFoodie = interests.some(interest => foodInterests.some(food => interest.includes(food)));
    const isHomebody = interests.some(interest => homeInterests.some(home => interest.includes(home)));

    let conversationInsights = 'They enjoy ';
    if (isActive) conversationInsights += 'active experiences and physical activities, ';
    if (isCultural) conversationInsights += 'cultural experiences and intellectual pursuits, ';
    if (isFoodie) conversationInsights += 'culinary adventures and food experiences, ';
    if (isHomebody) conversationInsights += 'cozy intimate moments and home-based activities, ';

    conversationInsights = conversationInsights.slice(0, -2); // Remove trailing comma

    return {
      stage,
      communicationStyle,
      budgetStyle,
      conversationInsights: conversationInsights || 'a variety of shared interests'
    };
  }

  /**
   * Generate fallback date ideas when AI fails
   */
  generateFallbackDateIdeas(interests, location, chatMetadata) {
    const baseIdeas = [
      {
        title: "Sunset Picnic & Stargazing",
        description: "Pack your favorite snacks and find a scenic spot to watch the sunset together, then stay for stargazing",
        conversationTopics: ["Share childhood memories under the stars", "Talk about your dreams and aspirations"],
        budget: "Low cost",
        timing: "Evening, clear weather"
      },
      {
        title: "Cooking Challenge Date",
        description: "Choose a cuisine neither of you has cooked before and create a meal together",
        conversationTopics: ["Share family recipes and food memories", "Plan future culinary adventures"],
        budget: "Moderate",
        timing: "Weekend afternoon"
      },
      {
        title: "Memory Lane Adventure",
        description: "Visit places that are meaningful to your relationship - where you first met, had your first date, etc.",
        conversationTopics: ["Reminisce about your early relationship", "Share what you love most about your journey together"],
        budget: "Variable",
        timing: "Full day weekend"
      },
      {
        title: "Creative Workshop Date",
        description: "Take a pottery, painting, or craft class together and create something meaningful",
        conversationTopics: ["Discuss your creative sides", "Plan future artistic projects together"],
        budget: "Moderate to high",
        timing: "Weekend or evening"
      },
      {
        title: "Local Explorer Date",
        description: "Be tourists in your own city - visit a museum, try a new neighborhood, or take a walking tour",
        conversationTopics: ["Share what you love about your city", "Plan future travel adventures"],
        budget: "Low to moderate",
        timing: "Weekend day"
      }
    ];

    // Customize based on interests
    if (interests.includes('food') || interests.includes('cooking')) {
      baseIdeas[1].title = "Gourmet Cooking Adventure";
      baseIdeas[1].description = "Since you both love food, try making a complex dish from scratch or recreate a meal from your favorite restaurant";
    }

    if (interests.includes('hiking') || interests.includes('outdoor')) {
      baseIdeas[0].title = "Hiking & Sunset Date";
      baseIdeas[0].description = "Find a scenic hiking trail that leads to a great viewpoint for sunset watching";
    }

    return baseIdeas;
  }

  // Summarize important moments
  async summarizeMemories(messages, timeframe) {
    const systemInstruction = `You are a thoughtful AI that helps couples cherish their memories. 
    Create beautiful, emotional summaries that capture the essence of their conversations and moments together.`;

    const prompt = `Create a beautiful summary of this couple's memories from ${timeframe}:

Sample messages:
${messages.map(m => `[${new Date(m.createdAt).toLocaleDateString()}] ${m.sender}: ${m.content.text}`).join('\n')}

Write a heartfelt summary that:
- Captures key moments and conversations
- Highlights emotional milestones
- Uses poetic but accessible language
- Celebrates their journey together
- Ends with an inspiring message about their future`;

    const response = await this.generateContent(prompt, systemInstruction);
    return this.parseMemorySummary(response);
  }

  // Helper methods to parse responses
  parseRelationshipAnalysis(response) {
    try {
      // First try to parse as JSON
      return JSON.parse(response);
    } catch (e) {
      // Fall back to simple parsing
      const lines = response.split('\n');
      const analysis = {
        healthScore: 8,
        communicationPatterns: [],
        positiveObservations: [],
        areasForGrowth: [],
        suggestions: []
      };

      let currentSection = '';
      lines.forEach(line => {
        if (line.includes('score') && line.match(/\d+/)) {
          analysis.healthScore = parseInt(line.match(/\d+/)[0]);
        } else if (line.toLowerCase().includes('pattern')) {
          currentSection = 'patterns';
        } else if (line.toLowerCase().includes('positive')) {
          currentSection = 'positive';
        } else if (line.toLowerCase().includes('growth')) {
          currentSection = 'growth';
        } else if (line.toLowerCase().includes('suggestion')) {
          currentSection = 'suggestions';
        } else if (line.trim()) {
          switch (currentSection) {
            case 'patterns':
              analysis.communicationPatterns.push(line.trim());
              break;
            case 'positive':
              analysis.positiveObservations.push(line.trim());
              break;
            case 'growth':
              analysis.areasForGrowth.push(line.trim());
              break;
            case 'suggestions':
              analysis.suggestions.push(line.trim());
              break;
          }
        }
      });

      return analysis;
    }
  }

  parseConversationStarters(response) {
    const lines = response.split('\n').filter(line => line.trim());
    const starters = [];

    lines.forEach(line => {
      // Look for numbered items or bullet points
      if (line.match(/^\d+\.|^-|^•/) && line.length > 10) {
        starters.push(line.replace(/^\d+\.|^-|^•/, '').trim());
      }
    });

    return starters.slice(0, 5);
  }

  parseEmojiAnalysis(response) {
    return {
      analysis: response,
      insights: response.split('\n').filter(line => line.trim()).slice(0, 4)
    };
  }

  parseDateIdeas(response) {
    const lines = response.split('\n').filter(line => line.trim());
    const ideas = [];
    let currentIdea = null;

    lines.forEach(line => {
      if (line.match(/^\d+\.|Date Idea/i)) {
        if (currentIdea) ideas.push(currentIdea);
        currentIdea = {
          title: line.replace(/^\d+\.|Date Idea:?/i, '').trim(),
          description: '',
          conversationTopics: []
        };
      } else if (currentIdea) {
        if (line.toLowerCase().includes('conversation') || line.toLowerCase().includes('talk about')) {
          currentIdea.conversationTopics.push(line.trim());
        } else {
          currentIdea.description += line.trim() + ' ';
        }
      }
    });

    if (currentIdea) ideas.push(currentIdea);
    return ideas.slice(0, 5);
  }

  parseMemorySummary(response) {
    return {
      summary: response,
      highlights: response.split('\n')
        .filter(line => line.trim())
        .filter(line => line.includes('❤️') || line.includes('💕') || line.includes('✨'))
    };
  }
}

// Create and export a singleton instance
const geminiService = new GeminiService();

// Export both the class and instance
module.exports = {
  GeminiService,
  geminiService
};
